{% extends "ladder/base.html" %}
{% load url from future %}
{% load static from staticfiles %}
{% comment %}
	when inheriting from another template, the first line in the file should declare the inheritance.
	This is a must. Otherwise template inheritance will not work
{% endcomment %}
{% comment %} This defines comments within a template {% endcomment %}
{% comment %} OF SEARING IMPORTANCE: the 'extends' tag should be the first to appear
in order for template inheritance to work! {% endcomment %}
{% comment %} The following loads the 'static' tag, so that it can be used to load
static file assets {% endcomment %}
{% load static from staticfiles %}

{% block pagetitle %}Rutas de Carrera{% endblock %}

{% block includestylesheet %}
{% comment %} 
	The following tag outputs original text from the parent template
	so that the parent's content for this section isn't completely overridden
	
	In this case, CSS from the master form template will be added to this page's
	html-head
{% endcomment %}
		{{ block.super }}
{% endblock %}

{% block includejavascript %}
{% comment %} 
	The following tag outputs original text from the parent template
	so that the parent's content for this section isn't completely overridden 
	
	In this case, javascript from the master template will be added to this page's
	html-head
{% endcomment %}
		{{ block.super }}
{% endblock %}

{% block pagestyle %}

	.ui-autocomplete-loading {
        background: white url('{% static "ladder/images/ui-anim_basic_16x16.gif" %}') right center no-repeat;
    }
    
    .background_jobs_pending {
    	background: white url('{% static "ladder/images/ui-anim_basic_16x16.gif" %}') right center no-repeat;
    	width: 16px;
    	height: 16px;
    	margin: 3px 3px;
    }
    
    .ui-autocomplete {
        max-height: 100px;
        max-width: 250px;
        overflow-y: auto;
        overflow-x: hidden;
        height: 100px;
        width: 250px;
    }
    
    .ui-combobox {
        position: relative;
        display: inline-block;
    }
    .ui-combobox-toggle {
        position: absolute;
        top: 0;
        bottom: 0;
        margin-left: -1px;
        padding: 0;
        /* adjust styles for IE 6/7 */
        *height: 1.7em;
        *top: 0.1em;
    }
    .ui-combobox-input {
        margin: 0;
        padding: 0.3em;
    }

{% endblock %}

{% block pageheader %}
	<h1>Rutas de carrera</h1>
{% endblock %}

{% block pagebody %}
	<div>
		<div class='input-append'>
			<label for='cargo_inicial_nombre'>Cargo actual: </label>
			<select id='cargo_inicial_nombre' name='cargo_inicial_nombre' type='text' class='dropdown'></select>
		</div>
		<span class='help-block'>Elige el cargo que tienes en este momento</span>
	</div>
	<div class='toggled_by_cargo_inicial'>
		<div class='input-append'>
			<label for='cargo_destino_nombre'>Cargo Destino: </label>
			<select id='cargo_destino_nombre' name='cargo_destino_nombre' type='text'></select>
		</div>
		<span class='help-block'>Elige el cargo al que quieres llegar</span>
	</div>
	<div id='dialog-wait' title='Por favor espera...'>
		<div class='control-group warning'>
			<p style='margin-top: 5px;'>
				<i class='icon-road' style='margin: 3px 7px 0px 7px; float: left;'></i>
				<span id='msg-content'>Estamos calculando tus planes de carrera</span>
			<p>
		</div>
	</div>
{% endblock %}

{% block pagefooter %}
	<script>
		//this is 'work queue'... all objects in this collection are primary keys for objects to be processed
		var pendingCargos = [];
		//collection of leaf nodes
		var destinations = [];
		//an object that acts as if it were a hash table to keep track of visited objects
		var futurePaths = {};
		
		//use scrap data from futurePaths to calculate all possible routes
		function rebuildPaths(){
			//this will have a pointer for each node visited in the graph
			var keys = [];
			//collect pointers for all visited objects
			for(var key in futurePaths){
				keys[keys.length] = key;
			}
			//console.log(keys);
			//for each visited object, build a js statement to get a handle on it's data
			for(var i = 0; i < keys.length; i++){
				//plain text js statement that points to a graph object
				var node = "futurePaths['" + keys[i] + "']";
				//console.log(keys[i]);
				//console.log(node);
				//console.log(eval(node));
				//evaluate js statement to grab the object
				node = eval(node);
				//console.log(node.fields.siguientes);
				//for every node referenced by the current object
				for(var j = 0; j < node.fields.siguientes.length; j++){
					//console.log('-->'+ node.fields.siguientes[j]);
					//plain text js statement that points to the reference target
					var reference = "futurePaths['" + node.fields.siguientes[j] + "']";
					//evaluate js statement to grab the reference target
					reference = eval(reference);
					//replace target key with actual object reference
					node.fields.siguientes[j] = reference;
					//console.log(reference);
				}
			}
			//populate destination dropdown
			populateDropdownOptions(futurePaths, '#cargo_destino_nombre');
			//dismiss wait dialog
			toggleWaitDialog();
			//display destination cargos
			$('.toggled_by_cargo_inicial').css('visibility','visible');
		}
		
		//try to empty  the pendingCargos collection by processing each of it's contents
		function calculateRouteEndpoints_inspectChildrenFor(){
			//console.log('pending: ' + pendingCargos.length);
			//if there are no more items left to process, then stop
			if(pendingCargos.length <= 0)
				return;
			//dequeue a node and prevent it from being re-visited
			var node = pendingCargos[0];
			//dont re-visit a node... purge redundant items in the work queue
			while(futurePaths[ node ] && pendingCargos.length > 0){
				//console.log('already visited: ' + futurePaths[ node ]);
				pendingCargos = pendingCargos.slice(1, pendingCargos.length);
				//console.log('still have to check for: ' + pendingCargos.length + ' more node(s)');
				node = pendingCargos[0];
				//console.log('skipping to: ' + node);
			}
			//if the work queue is empty, then all nodes are done processing
			if(!node || node == null || node == undefined){
				//use server-side data to rebuild the graph
				rebuildPaths();
			}
			//abort work in progress current node has already been visited
			if(!node || futurePaths[ node ])
				return;
			//mark node being processed as visited
			futurePaths[ node ] = node;
			//print this for debugging
			//console.log('processing: ' + node);
			//request data for the node being processed
			$.ajax({
				url: "{% url 'get-cargo-by-pk' 1 %}".slice(0,-2) + node + "/"
				, dataType: "json"
				, success: function(data, textStatus, jqXHR){
					//if the server-side data points to any other graph nodes, then schedule them for future processing
					if(data[0] && data[0].fields && data[0].fields.siguientes){
						//for each referenced node in the server-side data
						for(var i = 0; i < data[0].fields.siguientes.length; i++){
							//if the referenced node has yet to be processed, queue it for future processing
							if( !futurePaths[ data[0].fields.siguientes[i] ] ){
								//add pending node to the work queue
								pendingCargos[pendingCargos.length] = data[0].fields.siguientes[i];
							}
						}
					} 
					//if server-side data doesn't point to any other nodes
					if( data[0].fields.siguientes.length <= 0 ) {
						//this is a leaf. Save it for later use
						destinations[ destinations.length ] = node;
					}
					//save data about this node. This is the raw server-side data and will be used to rebuild the graph once all
					//nodes are done processing
					futurePaths[ node ] = data[0];
					//re-start work on pending items, if any
					if(pendingCargos.length>0){
						calculateRouteEndpoints_inspectChildrenFor();
					}
				}
				, error: function(jqXHR, textStatus, errorThrown){
					alert(textStatus);
				}
				, complete: function(jqXHR, textStatus){
					
				}
			});
		}
		
		//calculate available career routes from a given starting point
		//offSet: stands for a server-side primary key
		function calculateRouteEndpoints(offSet){
			//clear work queue
			pendingCargos = [];
			//clear previous results, if any
			destinations = [];
			futurePaths = {};
			//queue a graph node for processing
			pendingCargos[pendingCargos.length] = offSet;
			//trigger graph walking algorithm
			calculateRouteEndpoints_inspectChildrenFor();
			//show please wait dialog
			toggleWaitDialog('Estamos buscando planes de carrera a partir del cargo que ocupas','icon-filter');
		}
		
		//load all available cargos
		function loadOffsetCargos(){
			//show please wait dialog
			toggleWaitDialog('Estamos cargando los cargos que puedes ocupar en la organizaci√≥n','icon-signal');
			$.ajax({
				url: "{% url 'get-cargos' %}"
				, dataType: "json"
				, data: {
					//don't send any data to the service
				}, success: function(data, textStatus, jqXHR){
					populateDropdownOptions(data, '#cargo_inicial_nombre');
				}, complete: function(jqHXR, textStatus){
					//done requesting data
					toggleWaitDialog();
				}, error: function(jqXHR, textStatus, errorThrown){
					alert(textStatus);
				}
			});
			$('select').combobox();
		}
		
		//prepare wait dialog
		function setupWaitDialog(){
			$( "#dialog-wait" ).dialog({
				resizable: false,
				height:140,
				modal: true,
				autoOpen: false,
				closeOnEscape: false,
				show: 'explode',
				hide: 'explode',
			});
		}
		
		//hides or shows the please wait dialog
		//text: text you want displayed by the wait dialog
		//icon: bootstrap glyphicon style for the dialog image
		function toggleWaitDialog(text, icon){
			//find out if dialog is opened up
			if($("#dialog-wait").dialog( "isOpen" )){
				//if dialog is opened up, then close it
				$("#dialog-wait").dialog( "close" );
			}else {
				if(text){
					$('#dialog-wait #msg-content').text(text);
				}
				if(icon){
					var iconImage = $('#dialog-wait i');
					var currentStyle = iconImage.attr('class');
					iconImage.removeClass(currentStyle).addClass(icon);
				}
				//display dialog
				$("#dialog-wait").dialog( "open" );
				//hide the close dialog handle
				$('a.ui-dialog-titlebar-close', $('#dialog-wait').prev()).hide();
			}
		}
		
		//iterates trough whatever contents are in the array or object represented by 'data'
		//data: info to be used when populating a drop down list
		//jqSelectorForDropown: jquery selector that points to the dropdown where data is to be appended
		function populateDropdownOptions(data, jqSelectorForDropown){
			$(jqSelectorForDropown+' option').remove()
			$.map( data, function( item ) {
				$(jqSelectorForDropown).append(
					$('<option value="' + item.pk + '">' + item.fields.nombre + '</option>')
				);
			})
		}
	
		$(document).ready(function(){
			//fix dialogs
			setupWaitDialog();
			//load cargo list
			loadOffsetCargos();
			//fix sizes for input fields
			$('div.input-append button').css('height','2em');
			$('div.input-append input').css('height','1.3em');
			
			$('#cargo_inicial_nombre').change(function(){
				var selected = $('#cargo_inicial_nombre option:selected')[0].value;
				calculateRouteEndpoints(selected);
				/*
				$.ajax({
					url: "{% url 'get-cargos-destino' 1 %}".slice(0,-2) + selected + "/"
					, dataType: "json"
					, data: {
						//don't send any data to the service
					}, success: function(data, textStatus, jqXHR){
						$('#cargo_destino_nombre').empty();
						$.map( data, function( item ) {
							$('#cargo_destino_nombre').append(
								$('<option value="' + item.pk + '">' + item.fields.nombre + '</option>')
							);
						})
					}, complete: function(jqXHR, textStatus){
						//done requesting data
					}, error: function(jqXHR, textStatus, errorThrown){
						alert(textStatus);
					}
				});
				*/
			});
			/*
			$('#cargo_inicial_nombre').autocomplete({
				source: function(request, response){
					console.log("{% url 'get-cargos' %}" + request.term + "/");
					$.ajax({
						url: "{% url 'get-cargos' %}" + request.term
						, dataType: "json"
						, data: {
							//don't send any data to the service
						}, success: function(data, textStatus, jqXHR){
							response( $.map( data, function( item ) {
								return {
									label: item.fields.nombre,
									value: item.pk
								}
							}));
						}, complete: function(jqXHR, textStatus){
							//done requesting data
						}, error: function(jqXHR, textStatus, errorThrown){
							alert(textStatus);
						}
					});
				}, minLength: 2,
				select: function(event, ui){
					if(ui.item){
						console.log(ui.item.value);
						$('#cargo_inicial_nombre').val(ui.item.label);
						$('#cargo_inicial').val(ui.item.value);
						return false;
					}
				}, open: function(){
					$(this).removeClass('ui-corner-all').addClass('ui-corner-top');
				}, close: function(){
					$(this).removeClass('ui-corner-top').addClass('ui-corner-all');
				}
			})*//*.data("autocomplete")._renderItem = function( ul, item ){
				return $( "<li>" )
                .data( "item.autocomplete", item )
                .append( "<a>" + item.label + "<br>" + item.value + "</a>" )
                .appendTo( ul );
			}*/;
		});
	</script>
	<script>
		//hide destination cargo until an offset cargo has been chosen
		$('.toggled_by_cargo_inicial').css('visibility','hidden');
	</script>
{% endblock %}
{% comment %}
	See built in thempalte tags and filters at:
	https://docs.djangoproject.com/en/dev/ref/templates/builtins/?from=olddocs
	
	See basic template syntax at:
	https://docs.djangoproject.com/en/dev/ref/templates/api/
	
	https://docs.djangoproject.com/en/1.4/topics/templates/
{% endcomment %}
